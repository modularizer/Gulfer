/**
 * Migration Index Generator
 * 
 * Automatically generates the migrations index file that setup.ts uses.
 * This runs automatically when you run `npm run db:generate`
 * 
 * Reads SQL files from separate migrations/sqlite/ and migrations/postgres/ folders.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

const MIGRATIONS_DIR = path.join(__dirname, './migrations');
const SQLITE_DIR = path.join(MIGRATIONS_DIR, './sqlite');
const POSTGRES_DIR = path.join(MIGRATIONS_DIR, './postgres');
const INDEX_FILE = path.join(__dirname, './migrations/index.ts');

interface Migration {
  name: string;
  hash: string;
  sql: string;
  postgres: string;
}

/**
 * Generate hash from SQL content
 */
function hashSQL(sql: string): string {
  return crypto.createHash('sha256').update(sql).digest('hex').substring(0, 16);
}

/**
 * Convert SQLite SQL to PostgreSQL SQL
 * This is only used during generation, not at runtime
 */
function convertToPostgres(sqliteSQL: string): string {
  let result = sqliteSQL;
  // Convert backticks to double quotes
  result = result.replace(/`/g, '"');
  // Convert AUTOINCREMENT to SERIAL
  result = result.replace(/INTEGER PRIMARY KEY AUTOINCREMENT/gi, 'SERIAL PRIMARY KEY');
  return result;
}

/**
 * Read all migration files and generate index
 */
function generateMigrationsIndex(): void {
  console.log('üì¶ Generating accounts migrations index...');
  
  // Ensure directories exist
  if (!fs.existsSync(SQLITE_DIR)) {
    fs.mkdirSync(SQLITE_DIR, { recursive: true });
  }
  if (!fs.existsSync(POSTGRES_DIR)) {
    fs.mkdirSync(POSTGRES_DIR, { recursive: true });
  }
  
  // Find all SQLite migration files
  const sqliteFiles = fs.existsSync(SQLITE_DIR)
    ? fs.readdirSync(SQLITE_DIR)
        .filter(file => file.endsWith('.sql'))
        .sort() // Sort to ensure order
    : [];
  
  if (sqliteFiles.length === 0) {
    console.warn('‚ö†Ô∏è  No SQLite migration files found.');
    fs.writeFileSync(INDEX_FILE, `export default [] as Array<{ name: string; hash: string; sql: string; postgres: string }>;\n`);
    return;
  }
  
  const migrations: Migration[] = [];
  
  for (const file of sqliteFiles) {
    const sqlitePath = path.join(SQLITE_DIR, file);
    const sqliteSQL = fs.readFileSync(sqlitePath, 'utf-8');
    const hash = hashSQL(sqliteSQL);
    const name = file.replace('.sql', '');
    
    // Read PostgreSQL version from postgres folder, or generate it
    const postgresPath = path.join(POSTGRES_DIR, file);
    let postgresSQL: string;
    
    if (fs.existsSync(postgresPath)) {
      // Use existing PostgreSQL migration file
      postgresSQL = fs.readFileSync(postgresPath, 'utf-8');
    } else {
      // Generate PostgreSQL version from SQLite version and save it
      postgresSQL = convertToPostgres(sqliteSQL);
      fs.writeFileSync(postgresPath, postgresSQL);
      console.log(`   Generated PostgreSQL migration: ${file}`);
    }
    
    migrations.push({
      name,
      hash,
      sql: sqliteSQL.trim(), // SQLite version
      postgres: postgresSQL.trim(), // PostgreSQL version
    });
  }
  
  // Generate TypeScript file with embedded SQL
  // We'll create migration objects directly in the array
  const migrationObjects: string[] = [];
  
  migrations.forEach((migration) => {
    // Escape backticks, ${}, and backslashes in SQL for template literal
    const escapeSQL = (sql: string) => sql
      .replace(/\\/g, '\\\\')  // Escape backslashes first
      .replace(/`/g, '\\`')     // Escape backticks
      .replace(/\${/g, '\\${'); // Escape template literal expressions
    
    const escapedSQLite = escapeSQL(migration.sql);
    const escapedPostgres = escapeSQL(migration.postgres!);
    
    migrationObjects.push(`{
    name: '${migration.name}',
    hash: '${migration.hash}',
    sql: \`${escapedSQLite}\`,
    postgres: \`${escapedPostgres}\`
  }`);
  });
  
  const content = `/**
 * Migration Files Index
 * 
 * This file is auto-generated by generate-migrations-index.ts
 * Do not edit manually. Run \`npm run db:generate\` to regenerate.
 * 
 * Contains all migration SQL files that will be executed at runtime.
 * Each migration has both SQLite and PostgreSQL versions.
 */

export default [
${migrationObjects.map(m => '  ' + m).join(',\n')}
] as Array<{ name: string; hash: string; sql: string; postgres: string }>;
`;
  
  fs.writeFileSync(INDEX_FILE, content);
  
  console.log(`‚úÖ Generated accounts migrations index with ${migrations.length} migration(s)`);
  console.log(`   Index file: ${INDEX_FILE}`);
}

generateMigrationsIndex();

