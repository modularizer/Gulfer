/**
 * Migration Index Generator
 * 
 * Automatically generates the migrations index file that setup.ts uses.
 * This runs automatically when you run `npm run db:generate`
 * 
 * Reads all SQL files from migrations/ and creates an index with their content.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

const MIGRATIONS_DIR = path.join(__dirname, '../migrations');
const INDEX_FILE = path.join(__dirname, 'migrations/index.ts');

interface Migration {
  name: string;
  hash: string;
  sql: string;
}

/**
 * Generate hash from SQL content
 */
function hashSQL(sql: string): string {
  return crypto.createHash('sha256').update(sql).digest('hex').substring(0, 16);
}

/**
 * Read all migration files and generate index
 */
function generateMigrationsIndex(): void {
  console.log('üì¶ Generating migrations index...');
  
  if (!fs.existsSync(MIGRATIONS_DIR)) {
    console.warn(`‚ö†Ô∏è  Migrations directory not found: ${MIGRATIONS_DIR}`);
    console.warn('   Run `npm run db:generate` first to create migrations.');
    // Create empty index
    fs.writeFileSync(INDEX_FILE, `export default [] as Array<{ name: string; hash: string; sql: string }>;\n`);
    return;
  }
  
  // Find all SQL files
  const files = fs.readdirSync(MIGRATIONS_DIR)
    .filter(file => file.endsWith('.sql'))
    .sort(); // Sort to ensure order
  
  if (files.length === 0) {
    console.warn('‚ö†Ô∏è  No migration files found.');
    fs.writeFileSync(INDEX_FILE, `export default [] as Array<{ name: string; hash: string; sql: string }>;\n`);
    return;
  }
  
  const migrations: Migration[] = [];
  
  for (const file of files) {
    const filePath = path.join(MIGRATIONS_DIR, file);
    const sql = fs.readFileSync(filePath, 'utf-8');
    const hash = hashSQL(sql);
    const name = file.replace('.sql', '');
    
    migrations.push({
      name,
      hash,
      sql: sql.trim(),
    });
  }
  
  // Generate TypeScript file with embedded SQL
  // We'll create migration objects directly in the array
  const migrationObjects: string[] = [];
  
  migrations.forEach((migration) => {
    // Escape backticks, ${}, and backslashes in SQL for template literal
    const escapedSQL = migration.sql
      .replace(/\\/g, '\\\\')  // Escape backslashes first
      .replace(/`/g, '\\`')     // Escape backticks
      .replace(/\${/g, '\\${'); // Escape template literal expressions
    
    migrationObjects.push(`{
    name: '${migration.name}',
    hash: '${migration.hash}',
    sql: \`${escapedSQL}\`
  }`);
  });
  
  const content = `/**
 * Migration Files Index
 * 
 * This file is auto-generated by generate-migrations-index.ts
 * Do not edit manually. Run \`npm run db:generate\` to regenerate.
 * 
 * Contains all migration SQL files that will be executed at runtime.
 */

export default [
${migrationObjects.map(m => '  ' + m).join(',\n')}
] as Array<{ name: string; hash: string; sql: string }>;
`;
  
  fs.writeFileSync(INDEX_FILE, content);
  
  console.log(`‚úÖ Generated migrations index with ${migrations.length} migration(s)`);
  console.log(`   Index file: ${INDEX_FILE}`);
}

generateMigrationsIndex();

