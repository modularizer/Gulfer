/**
 * Generate Migrations for generic-sports-data
 * 
 * Generates SQL migration files and creates the migrations index.
 * Converts backticks to double quotes for SQLite compatibility.
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import { convertBackticksToQuotes, hashSQL } from '../../../xp-deeby/utils';

const PROJECT_ROOT = path.join(__dirname, '../../../');
const CONFIG_PATH = path.resolve(__dirname, 'drizzle.config.ts');
const MIGRATIONS_DIR = path.join(__dirname, './migrations');
const INDEX_FILE = path.join(__dirname, './migrations/index.ts');

interface Migration {
  name: string;
  hash: string;
  sql: string;
}

/**
 * Generate migrations index
 */
function generateMigrationsIndex(): void {
  console.log('üì¶ Generating migrations index...');
  
  if (!fs.existsSync(MIGRATIONS_DIR)) {
    console.warn(`‚ö†Ô∏è  Migrations directory not found: ${MIGRATIONS_DIR}`);
    fs.writeFileSync(INDEX_FILE, `export default [] as Array<{ name: string; hash: string; sql: string }>;\n`);
    return;
  }
  
  // Find all SQL files
  const files = fs.readdirSync(MIGRATIONS_DIR)
    .filter(file => file.endsWith('.sql'))
    .sort();
  
  if (files.length === 0) {
    console.warn('‚ö†Ô∏è  No migration files found.');
    fs.writeFileSync(INDEX_FILE, `export default [] as Array<{ name: string; hash: string; sql: string }>;\n`);
    return;
  }
  
  const migrations: Migration[] = [];
  
  for (const file of files) {
    const filePath = path.join(MIGRATIONS_DIR, file);
    let sql = fs.readFileSync(filePath, 'utf-8');
    
    // Convert backticks to double quotes
    sql = convertBackticksToQuotes(sql);
    
    // Write back the converted SQL
    fs.writeFileSync(filePath, sql);
    
    const hash = hashSQL(sql);
    const name = file.replace('.sql', '');
    
    migrations.push({
      name,
      hash,
      sql: sql.trim(),
    });
  }
  
  // Generate TypeScript file with embedded SQL
  const migrationObjects: string[] = [];
  
  migrations.forEach((migration) => {
    // Escape double quotes, ${}, and backslashes in SQL for template literal
    // SQL uses double quotes (SQLite standard), template literal uses backticks
    const escapedSQL = migration.sql
      .replace(/\\/g, '\\\\')  // Escape backslashes first
      .replace(/"/g, '\\"')     // Escape double quotes (SQL uses double quotes)
      .replace(/\${/g, '\\${'); // Escape template literal expressions
    
    // Use double quotes in the string literal since SQL uses double quotes
    migrationObjects.push(`{
    name: '${migration.name}',
    hash: '${migration.hash}',
    sql: "${escapedSQL}"
  }`);
  });
  
  const content = `/**
 * Migration Files Index
 * 
 * This file is auto-generated by generate-migrations.ts
 * Do not edit manually.
 * 
 * Contains all migration SQL files that will be executed at runtime.
 */

export default [
${migrationObjects.map(m => '  ' + m).join(',\n')}
] as Array<{ name: string; hash: string; sql: string }>;
`;
  
  fs.writeFileSync(INDEX_FILE, content);
  
  console.log(`‚úÖ Generated migrations index with ${migrations.length} migration(s)`);
}

/**
 * Generate migrations for generic-sports-data
 */
function generateMigrations(): void {
  console.log('üîß Generating migrations for generic-sports-data...');
  
  try {
    // Step 1: Run drizzle-kit generate
    // Use 'inherit' to show output, but we'll check for actual failures
    let exitCode = 0;
    let output = '';
    try {
      output = execSync(`npx drizzle-kit generate --config "${CONFIG_PATH}"`, { 
        stdio: ['inherit', 'pipe', 'pipe'], // stdin inherit, capture stdout/stderr
        cwd: PROJECT_ROOT,
        encoding: 'utf-8'
      }) as string;
    } catch (execError: any) {
      exitCode = execError.status || execError.code || 1;
      output = (execError.stdout || '') + (execError.stderr || '') + (execError.message || '');
      
      // Check for specific error patterns
      if (output.includes('ERR_MODULE_NOT_FOUND') || 
          output.includes('Cannot find module') ||
          output.includes('Error')) {
        console.error('‚ùå Drizzle-kit encountered errors:');
        console.error(output);
        throw new Error(`Drizzle-kit failed with exit code ${exitCode}. See errors above.`);
      }
      
      // If exit code is non-zero, it's a real failure
      if (exitCode !== 0) {
        console.error('‚ùå Drizzle-kit failed:');
        console.error(output);
        throw execError;
      }
    }
    
    // Check if migrations directory was created and has files
    if (!fs.existsSync(MIGRATIONS_DIR)) {
      throw new Error('Migrations directory was not created. Drizzle-kit may have failed silently.');
    }
    
    const sqlFiles = fs.readdirSync(MIGRATIONS_DIR).filter(f => f.endsWith('.sql'));
    if (sqlFiles.length === 0) {
      console.error('‚ùå No migration files were generated.');
      if (output) {
        console.error('Drizzle-kit output:', output);
      }
      throw new Error('No migration files were generated. Check drizzle-kit output above for errors.');
    }
    
    // Step 2: Generate the migrations index (and convert backticks to quotes)
    generateMigrationsIndex();
    
    console.log('‚úÖ Migrations generated successfully!');
  } catch (error: any) {
    console.error('‚ùå Error generating migrations:', error);
    if (error.status !== undefined || error.code !== undefined) {
      console.error('   Exit code:', error.status || error.code);
    }
    if (error.stdout) {
      console.error('   stdout:', error.stdout.toString());
    }
    if (error.stderr) {
      console.error('   stderr:', error.stderr.toString());
    }
    process.exit(1);
  }
}

generateMigrations();

