/**
 * Migrations Index
 * 
 * This file is auto-generated by schema.gen()
 * Do not edit manually. Run the generate script to regenerate.
 * 
 * Loads all migration files from the migrations directory.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

const migrationsDir = __dirname;

interface Migration {
  name: string;
  hash: string;
  sql: string;
  postgres?: string;
}

function loadMigrationsFromDir(dir: string, dialect: 'sqlite' | 'postgres'): Migration[] {
  if (!fs.existsSync(dir)) {
    return [];
  }

  const files = fs.readdirSync(dir)
    .filter(f => f.endsWith('.sql'))
    .sort();

  return files.map(file => {
    const filePath = path.join(dir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const name = path.basename(file, '.sql');
    const hash = crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);
    
    return {
      name,
      hash,
      sql: content,
    };
  });
}

// Load migrations from both dialect directories
const sqliteMigrations = loadMigrationsFromDir(path.join(migrationsDir, 'sqlite'), 'sqlite');
const postgresMigrations = loadMigrationsFromDir(path.join(migrationsDir, 'postgres'), 'postgres');

// Combine migrations by name (assuming they have the same names)
const migrations: Migration[] = [];
const allNames = new Set([...sqliteMigrations.map(m => m.name), ...postgresMigrations.map(m => m.name)]);

for (const name of Array.from(allNames).sort()) {
  const sqlite = sqliteMigrations.find(m => m.name === name);
  const postgres = postgresMigrations.find(m => m.name === name);
  
  if (sqlite || postgres) {
    migrations.push({
      name,
      hash: sqlite?.hash || postgres?.hash || '',
      sql: sqlite?.sql || postgres?.sql || '',
      postgres: postgres?.sql,
    });
  }
}

export default migrations;
